@page "/search"
@using JournalApp.Models.Sqlite
@inject JournalApp.Services.EntryService EntryService
@inject JournalApp.Services.MoodService MoodService
@inject JournalApp.Services.TagService TagService
@inject NavigationManager Nav
@inject IJSRuntime JS

<MudText Typo="Typo.h4" Class="mb-4">Search Journal</MudText>

<!-- Filters -->
<MudPaper Class="pa-4 mb-4 rounded-xl" Elevation="0" Outlined="true">
    <MudGrid>
        <MudItem xs="12" md="5">
            <MudTextField @bind-Value="searchText" Label="Search entries..." Variant="Variant.Outlined" Margin="Margin.Dense" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" />
        </MudItem>
        <MudItem xs="6" md="3">
            <MudSelect T="int" @bind-Value="moodFilterId" Label="Mood" Variant="Variant.Outlined" Margin="Margin.Dense" AnchorOrigin="Origin.BottomCenter">
                <MudSelectItem Value="0">All Moods</MudSelectItem>
                @foreach (var m in moods)
                {
                    <MudSelectItem Value="@m.Id">@m.Name</MudSelectItem>
                }
            </MudSelect>
        </MudItem>
        <MudItem xs="6" md="2">
            <MudSelect T="string" @bind-Value="sortOption" Label="Sort By" Variant="Variant.Outlined" Margin="Margin.Dense" AnchorOrigin="Origin.BottomCenter">
                <MudSelectItem Value="@("date_desc")">Newest First</MudSelectItem>
                <MudSelectItem Value="@("date_asc")">Oldest First</MudSelectItem>
                <MudSelectItem Value="@("title_asc")">Title A-Z</MudSelectItem>
                <MudSelectItem Value="@("title_desc")">Title Z-A</MudSelectItem>
            </MudSelect>
        </MudItem>
        <MudItem xs="12" md="2" Class="d-flex align-center">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="OnSearchClicked" FullWidth="true" Class="rounded-lg" StartIcon="@Icons.Material.Filled.Search">Search</MudButton>
        </MudItem>

        <MudItem xs="6" md="3">
            <MudDatePicker Label="Start Date" @bind-Date="startDate" Variant="Variant.Outlined" Margin="Margin.Dense" />
        </MudItem>
        <MudItem xs="6" md="3">
            <MudDatePicker Label="End Date" @bind-Date="endDate" Variant="Variant.Outlined" Margin="Margin.Dense" />
        </MudItem>
        <MudItem xs="12" md="6" Class="d-flex align-center">
            <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="ToggleTags">
                @(_showTags ? "Hide Tags" : "Filter by Tags") (@selectedTagIds.Count selected)
            </MudButton>
        </MudItem>
    </MudGrid>

    @if (_showTags)
    {
        <MudDivider Class="my-3" />
        <MudText Typo="Typo.caption" Class="mb-2 d-block">Select Tags:</MudText>
        <div class="d-flex flex-wrap gap-2">
            @foreach (var t in allTags)
            {
                var selected = selectedTagIds.Contains(t.Id);
                <MudChip T="string" Variant="@(selected ? Variant.Filled : Variant.Outlined)" Color="@(selected ? Color.Primary : Color.Default)" OnClick="() => ToggleTag(t.Id)">@t.Name</MudChip>
            }
        </div>
    }
</MudPaper>

<!-- Results List -->
<MudPaper Class="rounded-xl" Elevation="0" Outlined="true">
    @if (pagedResults.Count == 0)
    {
        <div class="pa-6 text-center">
            <MudText Color="Color.Secondary">No matching entries found.</MudText>
        </div>
    }
    else
    {
        <MudList T="JournalEntry" Clickable="true" DisablePadding="true">
            @foreach (var e in pagedResults)
            {
                <MudListItem OnClick="@(() => OpenEntry(e.EntryDate))">
                    <div class="d-flex justify-space-between align-center">
                        <div>
                            <MudText Typo="Typo.subtitle1" Color="Color.Primary" Class="fw-bold">@e.EntryDate.ToString("yyyy-MM-dd") - @e.Title</MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-1">
                                Mood: @GetMoodName(e.PrimaryMoodId) â€¢ Words: @CountWords(e.Content)
                            </MudText>
                        </div>
                        <div class="d-flex gap-2">
                            <MudButton Variant="Variant.Outlined" Size="Size.Small" Color="Color.Primary" OnClick="@((MouseEventArgs x) => OpenEntry(e.EntryDate))">View</MudButton>
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" Size="Size.Small" OnClick="@((MouseEventArgs x) => DeleteEntry(e.EntryDate))" />
                        </div>
                    </div>
                </MudListItem>
                <MudDivider />
            }
        </MudList>
    }
</MudPaper>

<!-- Pagination -->
<div class="d-flex justify-center align-center mt-4 gap-4">
    <MudButton Variant="Variant.Outlined" Disabled="@(currentPage <= 1)" OnClick="PrevPage">Previous</MudButton>
    <MudText Color="Color.Secondary">Page @currentPage of @totalPages</MudText>
    <MudButton Variant="Variant.Outlined" Disabled="@(currentPage >= totalPages)" OnClick="NextPage">Next</MudButton>
</div>

@code {
    // Filters
    private string searchText = "";
    private int moodFilterId;
    private string sortOption = "date_desc";
    private DateTime? startDate;
    private DateTime? endDate;

    private readonly HashSet<int> selectedTagIds = new();

    // Mood dropdown values
    private List<Mood> moods = new();
    private Dictionary<int, string> moodNameById = new();

    // Tags
    private List<Tag> allTags = new();

    // Data
    private List<JournalEntry> pagedResults = new();

    // Pagination
    private int pageSize = 5;
    private int currentPage = 1;
    private int totalPages = 1;
    private int totalCount;
    private bool _showTags;

    protected override async Task OnInitializedAsync()
    {
        moods = await MoodService.GetAllAsync();
        moodNameById = moods.ToDictionary(m => m.Id, m => m.Name);

        allTags = await TagService.GetAllAsync();

        await RefreshResultsAsync();
    }

    private async Task OnSearchClicked()
    {
        currentPage = 1;
        await RefreshResultsAsync();
    }

    private async Task RefreshResultsAsync()
    {
        var moodIds = moodFilterId > 0 ? new List<int> { moodFilterId } : null;
        var tagIds = selectedTagIds.Count > 0 ? selectedTagIds.ToList() : null;

        totalCount = await EntryService.GetSearchCountAsync(
            searchText,
            startDate,
            endDate,
            moodIds,
            tagIds);

        totalPages = Math.Max(1, (int)Math.Ceiling(totalCount / (double)pageSize));
        if (currentPage > totalPages) currentPage = totalPages;

        pagedResults = await EntryService.SearchAsync(
            searchText,
            startDate,
            endDate,
            moodIds,
            tagIds,
            currentPage,
            pageSize,
            sortOption);
    }

    private async Task PrevPage()
    {
        if (currentPage > 1)
        {
            currentPage--;
            await RefreshResultsAsync();
        }
    }

    private async Task NextPage()
    {
        if (currentPage < totalPages)
        {
            currentPage++;
            await RefreshResultsAsync();
        }
    }

    private void ToggleTag(int tagId)
    {
        if (selectedTagIds.Contains(tagId))
            selectedTagIds.Remove(tagId);
        else
            selectedTagIds.Add(tagId);
    }

    private void ToggleTags()
    {
        _showTags = !_showTags;
    }

    private void OpenEntry(DateTime day)
    {
        var formatted = day.ToString("yyyy-MM-dd");
        Nav.NavigateTo($"/entry?date={formatted}");
    }

    private async Task DeleteEntry(DateTime day)
    {
        var confirm = await JS.InvokeAsync<bool>("confirm", "Delete this entry?");
        if (!confirm) return;

        await EntryService.DeleteByDateAsync(day);
        await RefreshResultsAsync();
    }

    private string GetMoodName(int moodId)
    {
        return moodNameById.TryGetValue(moodId, out var name) ? name : "-";
    }

    private static int CountWords(string? text)
    {
        if (string.IsNullOrWhiteSpace(text)) return 0;
        return text.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
    }
}
